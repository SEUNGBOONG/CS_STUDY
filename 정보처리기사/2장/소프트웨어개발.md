# 알고리즘

알고리즘의 성능 판단 기준에 속도가 빠져있다는 점을 기억해야한다. 속도가 아닌 수행량 기준으로 측정된다. 수행량 역시 모든 연산이 아닌 주요 연산을 기준으로 한다

순서도와 의사코드가있다. 엄격히 정해진 방식은 없지만 누구나 명확히 이해핼 수 있게 일관성 있는 표현양식을 사용해야한다.

1. 알고리즘 설계 기법:
    - 동적 계획법 : 문제를 해결하기 위해 문제를 더 작은 문제의 연장선으로 생각하는 방식
    - 탐욕적 알고리즘 : 분기마다 가장 최적의 해를 선택하여 결과를 도출
    - 재귀적 알고리즘 : 같은 풀이를 다시 불러오는 과정을 반복하는 방식
        - 역순으로 결과를 도출한다.
    - 근사 알고리즘
    - 분할 정복법 : 크고 방대한 문제를 효율적으로 풀 수 있는 단위로 작게 나누는 방식
    - 퇴각 검색법: 깊이우선탐색 알고리즘 DFS 가있다.

2. 선형구조 :
    - 스택 : LIFO 방식
        - 푸쉬할때마다 1씩 증가 스택 크기 넘어서면 오버플로우 발생
        - 팝은 언더플로우
        - 깊이 우선 탁색 재귀 호출 Linear List Post-fix 에 사용
    - 
    - 큐 : FIFO 방식
        - 프린터 스풀이나 입출력 버퍼 같은 대기 행렬에 적합한 자료구조이다.
        - 데이터가 삭제될때마다 프런트 값이 증가하므로 데이터를 다시 앞쪽으로 옮겨줘야한다.

        - 데크 : 양방향 큐
            - Left right 가 데이터 삽입 삭제에따라 1씩 증감함

        - 선형리스트: 같은 유형의 데이터가 연속된 공간에 저장되는 자료구조
            - 가장 단순한 구조로 접근 속도가 빠르다.
            - 삽입 삭제시 위치 이동이필요하므로 시간이 오래걸린다.
            - 대표적으로 Array;
            - 평균 이동횟수 (n+1)/2

        - 연결리스트 : 배열의 단점을 보완한 자료구조
            - 노드와 노드의 연결로 구성
            - 기억 공간이 추가로 필요 배열 보다 느리다.

3. 비선형구조
    - 트리 : 1:N의 계층 구조
    - N-1;
    - 이진 트리 포화 이진트리 완전 이진 트리 등으로 나뉜다.
    - 전이진트리: 마지막 레벨까지 모든 형제 노드가 0,2
    - 완전 이진트리 : 마지막 레벨의 노드는 왼쪽에서 오른쪽으로 채워져있는
    - 포화 이진트리 : 모든 형제노드가 2개인 트리

    - 중위 순회 왼쪽 자식 부모 형제
    - 전위 순회 : 부모 노드 자식노드
    - 후위 순회 : 자식 형제 부모

# 탐색

1. 선형 탐색 : 대상 데이터를 처음 부터 순차적으로 비교하여 검색
    - 데이터의 개수나 정렬 여부를 알지못해도 사용가능 데이터수가 적을 때 사용한다.
    - O(N) 사용

2. 이분 탐색 : 대상 데이터를 절반 씩 나누어 가며 검색
    - 검색 대상을 반을 나누어 가며 검색하는 방식
    - 반을 나눠서 점점 줄여가니까 O(logN)이다.

3. 보간 탐색: 찾을 값의 위치값을 예상하여 검색하는 사전식 탐색
    - O(log(logN))
4. 블록 탐색: 대량의 데이터를 그룹별로 블록화하여 인덱싱을 통해 검색
    - 블록화하여 인덱싱을 통해 검색
    - 예를 들어 제곱근을 사용하여 인덱싱
    - 15 60 사이의 숫자할때 15제곱근은 3이므로 3개의 블록으로 나눈다.

5. 이진 트리 탐색: 검색 대상 데이터를 이진 트리로 변형한 뒤에 검색
    - O(logN)
    - 첫 데이터를 근 노드로 정하고 이후 데이터를 트리 진행 순서대로 연결한다.
    -

6. 해싱 탐색: 해싱함수를 통하여 데이터를 검색
    - 시간 복잡도 : O(1)
    - 적절한 해시 함수를 사용하여 데이터를 검색하는 방식
    - 해싱 함수를 통해 결정된 저장위치가 충돌할 경우에는 적절한 조치가 필요하다. (*****)
    - 함수의 계산이 너무 복잡하지 않고 빠르게 처리될 수 있어야 한다.

# 복잡도

1. 공간 복잡도:
    - 알고리즘이 연산을 수행하며 사용되는 메모리 공간의 크기
    - 시간복잡도에비해 품질에 영향을 미치는 비중은 낮다.
    - 빅데이터 처리시 생각

2. 시간 복잡도
    - 탐색 등을 진행하는 대상 알고리즘으로 인해 연산이 수행되는 횟수를 나타내는 단위
    - 연산의 횟수가 보다 정확한 기준인된다.
    - 최악의 경우를 기준으로 산출한다.
    - 빅 오 표기법으로 시간복잡도를 나타낸다.

        - O(1): 가장 빠르다.
        - O(logN): 연산 횟수가 늘어나는 폭이 점점 줄어드는 시간 복잡도 그래프를 그려보고 생각하면된다.
            - 이분 탐색, 이진 트리 탐색에 활용됨, 이분 탐색 이진트리 둘다 반을 나눠가며 탐색하는건데 점점 줄어드니까.. 지수함수

        - O(N): 일정하게 증가하는 시간 복잡도
            - 선형 시간 알고리즘이라고 부르고 수열 계산에 이용된다.
        - O(NlogN): 연산 횟수가 늘어나느 폭이 점점 커지는 시간 복잡도
            - 퀵 정렬, 힙정렬, 병합 정렬 등에 활용된다.

        - O(N^2): 입력 데이터 수에 따라 연산횟수가 데이터 수의 제곱만큼 필요한 시간 복잡도
            - 비효율적인 알고리즘 선택정렬 버블 정렬 등이 속한다.

      -O(2^n): 피보나치수열

# 정렬

1. 선택 정렬 :
    - 기준 값을 선택된 데이터를 나머지 데이터와 비교하는 정렬 방식
    - O(N^2)

2. 버블 정렬 :
    - 기준값으로 지정한 데이터와 해당 데이터의 다음 데이터와 비교한다.
    - O(N^2)

3. 삽입 정렬 :
    - 정렬 대상 중 좌측에 이미 정렬된 요소와 비교하여 자신의 위치를 찾아 삽입하는 정렬 방식
    - 좌측 데이터와 비교 두 번째 데이터부터 정렬을 진행한다.
    - O(N^2)

4. 쉘 정렬
    - N개의 데이터를 가진 자료 구조의 간격을 구함
    - 삽입정렬의 단점을 보왆나 정렬 방식
    - 데이터들의 간격을 정하고 간격을 점차 줄여가면서 삽입 정렬 진행

5. 힙 정렬
    - 정렬 대상을 완전 이진 트리 형태로 만들어 정렬하는 방식

6. 이진 병합 정렬
    - 두 데이터를 한 쌍으로 병합하여 정렬하고 두 그룹을 다시 한쌍으로 정렬 반복

# 통합 구현

1. XML: 사용자가 임의로 생성한 태그를 통해 상세화
2. JSON: XML을 대체하는 독립적인 개방형 표준 형식 AJAX기술에서 많이 사용됨
3. YAML : JSON 에서 발전된 마크업 언어 사람이 쉽게 읽을 수 있음

# 연계 모듈 구현

- EAI : 전사적 애플리케이션 통합 환경
    - 송수신 어댑터를 이용해 메시지 변환 가능
    - 서로다른 코드나 프로토콜을 사용하는 시스템 간 통신이 가능
- PTP: 미들웨어 없이 직접 연결방식
    - 단순하 통합이 가능
    - 시스템 변경 재사용 어렵

- Hub & Spoke : 단일 접점 시스템 ( 허브 ) 통해 데이터를 전송하는 중앙 집중형 연계방식
    - 허브 장애발생시 전체 시스템 문제

    - Message Bus : 미들웨어인 버스를 두어 확장성과 처리량이 향상되는 방식
        - 보안 용이
        - 웹 서비스 기반 통신으로 표준화하기 어려움

# 제품 소프트웨어 패키징

1. Jenkins : 자바 언어 기반 웹 서버 기반 형상 관리도구연동가능
2. Gradle : 오픈 소스 테스크 단위 실행 플러그인 활용

# 릴리즈 노트

1. 테스트의 진행 이력 개발팀이 제공 사양을 얼마나 준수했는지 확인 할 수 있다.
2. 사용자에게 더 확실한 정보를 제공한다.

# DRM : 디지털 저작권 관리 구성요소

- 콘텐츠 제공자, 분배자 소비자 간의 패키징 배포 및 관리의 주체를 중앙의 클리어링 하우스에 이관하여 키 관리 및 라이선스 발급 관리를 진행한다.

# 버전 관리 (형 상 관 리 )

- 관리 방식에 따른 형상 관리 도구에는 공유 폴더 클라이언트/서버 분산 저장소 방식
- 저장소 구분
    - 로컬 형상 관리 시스템 : RSC
    - 중앙 집중형 형상 관리 시스템 :CVS, SVN, Clear Case
    - 분산형 형상관리 시스템 : Git, Mercurial () - > 속도에 중점을 둠 대규모 프로젝트에 좋다.
    -
    - 오픈 소스 관리도구 : CVS SVN
    - 상용 형상 관리도구 : PVCS, Clear Case

# S/W 테스트

1. 테스트란 사용자가 요구하는 기능 성능 사용성 안정성 등을 만족하는지 찾아내는 활동
2. 응용 애플리케이션 시스템의 결함을 찾아내어 문제점을 해결
3. 잠재된 오류를 발견하고 이를 수정하여 올바른 프로그램개발
4. 코드 리뷰 인스펙션 등을 통해 오류를 사전에 예방
5. 반복적인 테스트를 거쳐 신뢰도 향상

- 결함 집중 : 결함의 대부분은 특정 모듈에 집중 되어 있다.
    - 낚시의 법칙  : 낚시 포인트처럼 특정위치에서 발생
    - 파레토 법칙 : 결함의 80프로는 20퍼의 기능에서 발생
    - 살충제 패러독스 : 동일한 테스트 케이스로 반복실행 하면 새로운 결함 발견 불가능
    - 오류 부재의 궤변 : 결함이 없더라도 요구 사항을 만족하지 못한다면 품질 보증 불가능

- 정적 테스트: 프로그램 실행없이 소스 코드의 구조 분석
    - 인스펙션, 동료 검토 워크스루

- 동적 테스트 : 실행 화면을 보면서 테스트 수행
    - 블랙 박스테스트 : 요구사항 만족, 결과 값을 중심으로 테스트
        - 동등 분할 테스트 : 입력 조건에 유효한 값과 무효한 값을 균등하게 하여 테스트 케이스 설계
        - 경계값 분석 : 입력조건의 경계에서 오류가 발생할 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 설계
        - 원인 효과 그래프 : 입력 데이터 간의 관계와 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 설계한다.
        - 오류 예측 : 과거의 경험이나 확인자의 감각에 의존하여 테스트


- 화이트 박스 테스트 : 내부 로직을 중심으로 테스트를 진행
    - 기초 겅로 테스트
    - 제어 구조 검사

# 통합 테스트

1. V 모델 : 개발 단계별로 검증하고 수헹해야 하는 테스트
    - 요구사항 분석 - > 시스템 설계 - > 아키텍처 설계 - > 모듈 설계 - > 구현 - > 단위 테스트 - > 통합 테스트 - > 시스템 테스트 - > 인수 테스트
    - 단위 테스트 : 기능 중심 테스트 논리적인 오류 검출 일반적으로 화이트박스테스트로 한다.
    - 통합 테스트 : 컴포넌트 단위의 프로그램들이 설계 단계에서 제시한 애플리케이션과 동일한 구조와 기능으로 구현되었는지 확인하는 활동
        - 비점증적 방식 : 모든 모듈을 통합한 전체 프로그램을 한 번에 테스트
        - 점증적 방식: 하향싱 상향식 통합
        - 하향식 : 깊이우선 너비우선 방식이있다 .
            - Stub을 활용하여 테스트 내리막길 () -> 스탑 해야지
        - 상향식 : Driver 테스트 단계에서 존재하지않는 상위 모듈의 역할을 하는 더미 모듈

    - 인수 테스트 : 알파테스트 베타 테스트 가있다 .
        - 알파 테스트 : 개발자의 장소에서 진행 개발자와 문제점 함께 발견
        - 베타 테스트 : 제한되지 않은 환경에서 테스트 개발자에게 문제점 통보

# 애플리케이션 성능 측정

1. 성능 측정
    - 처리량(Throughput) : 주어진 시간에 얼마나 처리 할 수 있는지
    - 응답시간 (Response Time): 사용자 입력에 대한 응답이 나타날 떄 까지의 시간
    - 경과 시간 (Thunaround Time) : 사용자 입력에 대한 결과 출력이 완료될떄 까지의 시간
    - 자원 사용률 (Resource Usage) : 단위 작업 처리를 위한 CPU, 메모리 네트워크 등의 사용량

2. 성능 저하 원인
    - DB 연결 및 쿼리 실행 : DB Lock, DB Fetch
    - No commit
    - 내부 로직 오류
    - 스레드 풀 힙 메모리의 크기를 너무 작게 설정
