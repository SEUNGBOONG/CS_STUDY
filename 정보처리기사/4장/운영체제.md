# 레지스터 
1. CPU연산에 필요한 데이터 및 상태값을 일시적을 저장하는 장치
   - 메모리 중 가격 대비 용량이 작고 속도는 빠름
   - 플리플롭 래치로 구성
   - 플리플롭 : 동기식
   - 래치 : 비동기식
   - 제어장치 CU : 내부의 모든 장치들의 동작이나 연산을 제어하는 장치
   - 연산장치: ALU 명령에 따라 실제 연산을 수행하는 장치
     - 가산기 : 누산기와 데이터 레지스터에 보관된 값을 더하는 회로 
     - 누산기 연산의 결과를 일시적을 보관하는 레지스터
     - 상태레지스터: 연산 중 발생되는 이벤트 상태를 기억하는레지스터

# 시스템 버스 
1. 버스: 
   - 장치와 장치사이에 정보 교환을 위해 물리적으로 연결된 회선
   - 내부 버스: CPU 내부 요소 사이에서 정보를 전송하는 버스
   - 외부 버스: CPU와 주변장치 사이에서 정보를 전송하는 주소 버스 

2. 주소버스: 
   - 기억장치의 주소값을 전달하는 단방향 버스 
3. 데이터버스: 
   - 데이터 이동경로를 제공하는 양방향 버스
   - 다수의 분리된 회선으로 구성되며 회선의 개수가 곧 전송 가능 비트수를 의미

4. 제어버스 :
   - 주소버스와 데이터 버스를 제어하여 데이터 흐름을 관리하는 양방향 버스 


# 운영체제 
- 사용자가 컴퓨터 하드웨어를 효율적으로 운용할 수 있도록 인터페이스 제공
- 시스템 리소스를 관리해주고 다양한 서비스 프로그램 제공

- 응답 시간 : 작업이 입력되고, 처음 실행되기 까지 걸린 시간
- 대기 시간: 작업 시작 후 완료되기 전 까지의 작업이 진행되지않은 시간
- 실행 시간 : 작업 시작 후 완료되기 전 까지 작업이 진행된 시간
- 반환 시간: 실행시간 + 대기 시간 = 작업완료시간
- 시간 간격: 프로세스가 운영체제로부터 할당받은 시간


1. Window
2. UNIX
3. LINUX



# 프로세스 
1. 메모리에 적재되어 실행되고 있는 프로그램
2. 각 프로세스에 CPU가 할당되어 수행되며 프로세스 정보는 PCB에 기록
   - PCB : 프로세스에 대한 정보를 기록한 테이블 Process Control Block
   - 프로세스가 생성 될 때마다 고유의 PCB가 생성된다.
   - Time Slice에 의해 문맥 교환 수행 
   - 작은경우 문맥교환수 인터럽트 횟수 오버헤드 증가
   - 큰 경우 문맥교환수 인터럽트 횟수 오버헤드 감소 

3.  **** 상태
   - 준비 Ready: CPU할당 대기상태
   - 실행 Run : CPU를 할당받아 작업이 진행되고 있는 상태
   - 대기 Wait: 입출력처리를 위해 잠시 작업이 멈춘 상태
   

4. *** 전이과정 
   - Dispatch: 준비 상태의 프로세스를 실행 상태로 변경
   - Timer RunOut: 할당된 시간 안에 작업을 끝내지 못해 준비 상태로 변경
   - Block :  실행 상태 프로세스가 입출력 처리를 위해 대기 상태로 변경
   - Wake Up : 대기 상태 프로세스를 준비 상태로 변경
   > 준비 상태 -> 실행 상태  -> 대기상태 or 실행 
   > 
   > 대기상태 -> 준비상태   
   > Dispatch -> 디스패치를 통해 실행상태로 변경  -> 실행 중 시간 안에 작업을 끝내지 못할것 같다 ? -> 다시 준비상태로 보내야지 -> Timer RunOut 
   > 실행상태 프로세스가 입출력처리를 위한 상태로 - > 대기상태로 변경 이것 은 Block - > 대기상태로 갔으니 프로세스를 다시 준비로보내야지 ? -> Wake Up 꺠운다



# 인터럽트 
- 수행 중인 프로세스가 특정 요인에 의해 일시 중지 
- 다시 복귀하는 것

1. 외부 인터럽트: 
    - 입출력 장치 타이밍 장치 전원이상 기계착오등에서 일어나는 인터럽트

2. 내부 인터럽트: 
   - 잘못된 명령이나 데이터 사용할 떄 나오는 인터럽트


# 스레드 :
1. 프로세스 내에서 실행되는 흐름의 단위 경량 프로세스라고한다.
2. 일반적으로 하나의 프로세스는 하나의 단일 스레드를 가지지만, 둘 이상의 스레드를 동시에 실행되는 다중 스레드 방식도 있다.
3. 다중스레드의 독립 수행으로 병행성 증진
4. 응용 프로그램의 응답 시간 단축과 처리율을 향상
5. 프로세스간 통신이 향상되고 메모리 낭비 줄어든다.



## 프로세스 스케줄링 
# CPU 할당을 위해 프로세스들 사이의 우선순위를 부여 관리하는 것 
2. 장기 스케줄링 : 어떤 프로세스를 커널에 등록할 것인지를 결정
3. 중기 스케줄링 : 어떤 프로세스를 메모리에 할당할 것인지를 결정
4. 단기 스케줄링 : 어떤 프로세스에 CPU를 할당할 것인지를 결정


# 비선점형 스케줄링
1. FIFO : 
   - 프로세스가 도착한 순서대로처리
   - 간단하지만 반환 시간이 길다

2.  SJF : Short job First :
   - 실행시간이 가장 짧은 프로세스 순으로 처리
   - 실행시간이 긴 작업일 경우 무한 대기 상태 발생할 수 있다.

3. HRN :
   - 1, 2 단점을 보완해서 개발된것 
   - (대기시간 ) + (실행시간 ) / (실행시간 )




# 선점형 스케줄링 
1. RR: 
   - 동일한 Time Slice를 사용하는 시분할 처리 시스템
   - 단위로 프로세스를 처리한다. 
   - 피포와 동일

2. SRT : 
   - 작업이 끝나지않은 프로세스 남아 있는 실행 시간이 가장 작은 포르세스를 먼저 실행
   - 점유시간이 길어도 중요한 프로세스를 먼저 할당 가능 

3. MFQ :
   - 짧은 작업이나 입출력 위주의 프로세스에 우선순위 부여 
   - 우선순위가 있는 큐가 있으며 큐마다 타임 슬라이스 존재
   - #  맨마지막 큐는 RR 스케줄링 방식사용



# 프로세스 관련기술 
1. 상호배제 : 
   - 다수의 프로세스가 서로 공유하는 자원의 영역
   - 자원을 공유하는 프로세스는 동시 사용이 불가능
   - 독점도 불가능
   - 단일프로세스만 임계구역에 존제
   - 임계구역 진입이 무한정 연기 x
   - 다른 프로세스 침입 차단 
   - 속도나 개수에 영향 x


2. 교착 상태 :
   - 다수의 프로세스 같은 자원의 할당을 요구하며 무한 정 기다린다
   - 필요충분 조건
     - 상호배제
     - 점유와 대기
     - 비선점
     - 환형대기 

