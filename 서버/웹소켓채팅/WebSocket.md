# 웹소켓으로 채팅을 만들기 전 공부 

- 외부 API를 통해 웹소켓으로 데이터를 전달하는 것은 비교적 간단하다.
- 실제 채팅 시스템처럼 클라이언트 간 양방향 통신을 직접 설계하려면 고려해야할 복잡한 요소가 있다.
- 특히 채팅은 상태 관리, 연결 유지, 동시성 처리 등 여러 측면에서 공부하기에 좋을 것 같다.


# 채팅 시스템 구조 
--------------

1. WebSocket 서버
   - 클라이언트 연결을 관리하고 메시지를 송수신한다.
   - 메시지를 받아서 해당 채팅방으로 브로드 캐스트 하거나 특정 사용자에게 전달하는 로직을 포함한다.

2. 채팅방 Room 관리 
   - 여러 사용자가 서로 다른 방에서 채팅할 수 있도록 채팅방 개념을 도입
   - 서버에서 채팅방 목록과 사용자 정보를 관리해야한다.


3. 사용자 연결 관리 
   - 각 클라이언트의 세션을 관리
   - 연결이 끊기거나, 새로 접속했을 때 이를 처리하는 로직이 필요하다. 


# 복잡성을 만드는 요소들 
-------------------
1. 연결 상태 관리
   - 웹소켓은 클라이언트와 서버가 지속적으로 연결된 상태를 유지
   - 연결을 끊거나 비정상적으로 종료되었을 때 서버에서 적절히 처리해야한다 -> 어려운 부분이지 않을까 싶음

2. 동시성 문제
   - 다수의 사용자가 한 방에 있을 경우, 메시지가 올바르게 전달되도록 
     - Thread-Safety가 필요하다. 
3. 스케일링 
   - 유저 수가 많아질 경우 단일 서버로 감당하기 어려워짐
   - Redis 같은 Message Broker를 사용해 WebSocket 서버를 연결하느 로직이 필요할 수 있음 
4. 전송 형식:
   - JSon으로 데이터를 주고받는 경우가 많다. 메시지의 구조를 정의해야함.
5. 비동기 처리: 
   - 스프링에서 웹소켓은 비동기 기반으로 작동하므로 적절히 비동기 처리를 설계해야한다. 



# 채팅 개발 흐름 
------------------------
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-websocket'
}
--------------------------



# 추가로 고려해야 할 것들
--------------
1. 인증: 사용자가 누구인지 인증하고, 권한을 부여.
2. 채팅 기록 저장: Redis, RDBMS(MySQL) 등에 채팅 내용을 저장.
3. 로드밸런싱: 여러 WebSocket 서버를 사용하는 경우 세션을 공유하는 설계.


# 데이터 저장방식 차이
--------------
1. 즉시 저장 
- 데이터베이스에 메시지를 전달하고 완료 후 클라이언트로 전송 
- 메시지가 안정하게 저장된 후 전송되므로 유실 가능성 낮음 
- 채팅 기록 조회 시 항상 최산 상태
- 단점: 딜레이가 발생가능 

2. 전송 후 나중에 저장 
    - 응답 속도가 빠름 
    - 대량의 메시지 처리 편함 
    - 저장 실패시 데이터 유실가능성 

    


# 쓰레드 세이프티 
--------------
- 정의 : 여러 쓰레드가 동시에 동일한 데이터를 읽거나 수정할 때 데이터의 무결성을 보장하는 상태를 말한다. 
- 왜중요할까? : 다수의 클라이언트가 동시에 접속하여 메시지를 주고받을때 데이터 충돌이나 오류가 발생할 수 있음 
- 동기화를 통해 해결가능 -> Java의 ConcurrentHashMap, CopyOnWriteArrayList와 같은 자료구조는 기본적으로 쓰레드 세이프합니다.
- 스레드를 직접 제어하지 않고, Spring의 비동기 처리를 활용하여 작업을 분산.


# Redis와 메세지 브로커

--------------------------
- Redis는 인메모리 데이터 저장소로, 빠른 속도와 간편한 구조 덕분에 채팅 시스템에서 자주 사용됩니다.
- Redis의 Publish/Subscribe (Pub/Sub) 기능을 사용해 메시지를 브로드캐스트.
- 클라이언트가 채팅방을 구독(subscribe)하면, 서버가 메시지를 발행(publish)했을 때 자동으로 수신합니다.
- Redis에 사용자 연결 정보를 저장하여, 분산 서버 환경에서도 클라이언트를 추적할 수 있음.
- 최근 메시지나 사용자 상태(온라인/오프라인)를 Redis에 저장해 빠르게 접근. -> 캐싱 

- 메시지 브로커란? 
- 메시지 브로커는 발행자(Publisher)와 구독자(Subscriber) 사이에서 메시지를 전달하고 중계하는 역할을 합니다. 
- 대표적인 메시지 브로커:
- Redis: 가볍고 빠름. 소규모 애플리케이션에 적합.
- RabbitMQ: 고급 라우팅 기능 제공. 대규모 시스템에 적합.
- Kafka: 대량의 데이터 처리 및 내구성이 필요할 때 적합.



# 나중에 저장? 
-----------------
- 나중에 저장이 데이터베이스 관리에 유리한 이유 
  - 메시지를 바로 저장하지 않고, 비동기적으로 batch처리하거나 메시지 큐를 통해 저장하면 동시에 많은 쓰기 요청이 몰릴 수 있다.
  - EX) 채팅방에 수천 명이 메시지를 보낸다면 이를 모두 실시간 저장하면 데이터베이스 부하가 급격히 증가할 수 있음..
  - Redis나 Kafka 같은 메시지 큐에 메시지를 먼저 쌓아두고, 일정 시간(예: 1초) 간격으로 묶어서 데이터베이스에 저장.
  - 
@Async
public void saveMessagesBatch(List<ChatMessage> messages) {
chatMessageRepository.saveAll(messages);
}
- 쓰기 트랜잭션 비용 절감 
- 데이터베이스는 쓰기 작업(INSERT, UPDATE)의 비용이 읽기 작업(SELECT)보다 높습니다. 메시지를 한 번에 저장하면 트랜잭션 비용을 줄이고 성능을 개선할 수 있습니다. 
- 즉, 데이터베이스는 "여러 건을 한꺼번에 저장"하는 경우 성능이 더 나아집니다.
- 메시지를 즉시 데이터베이스에 저장하면, 클라이언트는 저장 완료를 기다리느라 응답 시간이 느려질 수 있습니다. 
- 메시지를 먼저 전달하고, 저장은 별도로 처리하면 사용자 경험이 향상됩니다.


# 즉시 저장(안정성 우선 방식)이 더 적합한 경우
- 데이터 유실 위험이 높은 경우 
- 메시지를 바로 데이터베이스에 저장하면, 서버 장애나 네트워크 문제 발생 시 데이터가 유실될 가능성이 줄어듭니다. 
- 특히 중요한 데이터(예: 금융 거래, 법적 기록)인 경우 반드시 즉시 저장해야 합니다. 
- 채팅 기록의 실시간 조회가 중요한 경우 
- 사용자가 채팅 기록을 바로 볼 수 있어야 한다면, 즉시 저장 방식이 필요할 수 있습니다. 
- 나중에 저장하면 메시지 전송과 데이터 저장 사이에 약간의 지연이 발생할 수 있습니다. 
- 저장 실패 방지 비동기 방식은 저장 실패 시 복구 로직이 필요합니다(예: Redis 장애 발생 시). 
- 즉시 저장은 데이터가 항상 안전하게 보관되므로 실패 가능성이 적습니다.


# 결론 
- 데이터베이스 관리가 우선이라면:
- 나중에 저장 방식을 권장. 
- 메시지 큐(예: Redis, Kafka)를 사용해 메시지를 쌓아두고, 배치로 데이터베이스에 저장하면 관리가 효율적. 
- 장점: 데이터베이스 부하 감소, 빠른 사용자 응답. 
- 데이터 안정성이나 실시간 처리가 우선이라면:

- 즉시 저장 방식을 선택. 
- 장점: 데이터 유실 가능성 최소화, 실시간 조회 보장.
- 소규모 채팅 애플리케이션: 즉시 저장 방식.
- 대규모 트래픽 환경: 나중에 저장 방식 + 메시지 큐 사용.
