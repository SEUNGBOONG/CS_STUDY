# 웹은 HTTP로 나타낸다.

- 주소 입력란에 URL을 입력하면 웹페이지가 열린다. 
- 서버에 의뢰를 하는 웹브라우정등을 클라이언트라고 부른다. 
- 즉 서버까지 일련의 흐름을 결정하는 것은 웹에서 HTTP라고 불리는 프로토콜이다.


 - 네트워크 기본은 TCP/IP
 - 컴퓨터와 네트워크 기기간 통신하기 위해서는 서로 같은 방법으로 해야한다.
 - 하드웨어와 운영체제 등을 가지고 서로 통신을 하기 위해서는 모든 요소에 규칙이 필요하다. 이것을 프로토콜이라고한다.
 - TCP/IP에서 중요한 개념 중 하나가 계층이다. 
 - 애플리케이션 계층
 - 트랜스포트 계층
 - 네트워크 계층
 - 링크 계층 
 - 인터넷이 하나의 프로토콜로 되어 있다면, 어디선가 사양이 변경되었을때 전체를 바꾸지 않으면 안되지만 계층화가 되어있으므로 해당 계층만 변경한다
 - 객체지향같네 .. ?
 - 상대가 어디에 있는지 어떠한 루트로 메시지를 전달하는지 전달한 메시지가 확실하게 전달되고 있는 지 같은 고려를 하지 않아도 된다.

1. 애플리케이션 계층:
   - 유저에게 제공되는 통신의 움직임을 결정
   - FTP DNS등 HTTP도 이 계층에 포함

2. 트랜스포트 계층 :
- 애플리케이션 계층에 네트워크로 접속되어 있는2대의 컴퓨터 사이의 데이터 흐름을 제공한다.
- TCP UDP  두 가지 프로토콜이 있다.

3. 네트워크 계층: 
   - 네트워크 상에서 패킷의 이동을 다룬다. 
   - 패킷 : 전송하는 데이터의 최소 단위
   - 어떠한 경로로 상대의 컴퓨터까지 패킷을 전달할지 결정함

4. 링크 계층:
   - 네트워크에 접속하는 하드웨어적인 면을 다룹니다.
   - 운영체제가 하드웨어를 제어하기 때문에
   - 디바이스 드라이버랑 네트워크 인터페이스 카드를 포함한다.
   - # 하드웨어적 측면은 모두 링크 계층의 역할이다.


- TCP/IP로 통신을 할 때 계층을 순서대로 거쳐 상대와 통신을 한다.
- 송신하는 측은 애플리케이션 계층에서부터 내려가고 수시한는 측은 애플리케이션 계층으로 올라간다.
- HTTP를 예로 웹페이지를 보고싶다 () -> HTTP Request 시작
- 메시지를 통신하기 쉽게 조각내어 안내번호와 포트번호를 붙여 네트워크 계층에 전달
- 네트워크 계층은 수신지 MAC 주소를 추가해서 링크 계층에 전달한다.


# HTTP와 관련 깊은 프로토콜은 IP/TCP/NDS

1. 배송을 담당하는 IP
   - 계층으로 말하자면 네트워크 층에 해당 
   - 개개의 패킷을 상대방에게 전달한다!!
   - MAC주소 IP 주소 필요하다 
   - IP주소는 각 노드에 부여된 주소를 가리키고 
   - MAC주소는 각 네트워크 카드에 할당된 고유의 주소이다
   - ARP를 이용하여 MAc주소에서 한다 
   - 아이피 주소는 맥주소에 의존해서 통신을한다. 인테넛에세 통신 상대가 같은 랜선 내에 있을 경우는 적어서 여러 대의 네트워크 기기를 중계해서 상대방에게 도착한다.
   - ARP라는 프로토콜 사용

- ARP 는 주소를 해결하기 위한 프로토콜 중 하나이다. 수신지의 IP 주소를 바탕으로 MAC 주소를 조사한다.


2. 신뢰성을 담당하는 TCP : 
   - 트랜스포트 층에 해당하는데 신뢰성 있는 바이트 스트림 서비스를 제공합니다. 
   - 바이트 스트림 서비스란 용량이 큰 데이터를 보내기 쉽게 TCP Segment라고 불리는 단위 패킷으로 작게 분해하여 관리한다.
   - 정확하게 도착했는지 확인하는 역할도 담당
   - TCP는 # 쓰리웨이 핸드 셰이킹이라는 방법을 사용한다. 
   - 이방법은 상대에게 잘갔는지 확인하는 것 


# 쿠키를 사용한 상태 관리 
- 스테이트리스 프로토콜이다 즉 과거에 관리했던 리퀘스트와 리스폰스의 상태를 관리하지 않는다.
- 이점은 있다. 상태를 유지하지 않는다. 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다.
-  이와 같은 문제를 해결하기 위해 쿠키라는 시스템이 도입됐다. 
- 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 한번 보내면 이제 나중에는 쿠키만 보내면 가능하게 하는것 

# HTTP 메시지 
- HTTP 메시지는 복수 행의 데이터로 구성된 텍스트 문자열 헤더와 바디로 구분 

# 메시지 
- 옥텟 시퀀스로 구성되고 통신을 통해서 전송

# 엔티티 
- 리퀘스트랑 리스폰스의 페이로드로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성


# MIME 
- 다목적인터넷 메일 확장 사양
- 텍스트나 영상 이미지와 같은 여러 다른 데이터를 다루기 위한 기능을 사용
- 아스키 문자열에 인코딩하는 방법과 데이터종류를 나타내는 방법등을 규정
- 멀티파트 라고 하는 여러 다른 종류의 데이터를 수용하는 방법을 사용하고 있음
- 레인지 리퀘스트에 대한 리스폰스는 상태코드 206 리스폰스 메시지가 되돌아 옵니다. 
- 지원하지않는 경우에는 상태코드 200OK라는 메시지로 완전한 엔티티가 되돌아온다.


# 콘텐츠 네고시에이션
- 클라이언트 서버 간 제공하는 리소스의 내용에 대해 교섭하는 것 
- 더욱 적합한 리소스를 제공하기 위한 구조
  - 서버 구동형 네고시에이션: 서버 측에서 리퀘스트 헤더필드의 정보를 참고해서 자동적으로 처리
  - 에이전트 구동형 네고시에이션 : 브라우저에서 표시된 선택지 중에서 유저가  수동으로 선택
    - JS 같은 것을 사용해서 자동적으로 이것을 정하는 것도 있다. 
    
  - 트랜스페어런트 네고시에이션
    - 서버 구동형과 에이전트 구동형을 혼합한 것 서버와 클라이언트 각각 콘텐츠 네고시에이션을 하는 방식


# 프록시 
- 서버와 클라이언트 양쪽 역할을 하는 중계 프로그램 
- 클라이언트로부터 리퀘스트를 서버에 전송 리스폰스를 클라이언트에게 전달
- - 클라이언트로부터 받은 리퀘스트를 다른 서버에 전송
- 클라이언트로부터 받은 리퀘스트 URL을 변경하지 않고 그 다음의 리소스를 가지고 있는 서버에 보낸다.
- 중계할 때 Via헤더 필드에 경유한 호스트 정보를 추가해야한다.

- 캐싱 프록시 : 프록시 서버 상에 리소스 캐시를 보존 해두는 타입
- 투명 프록시 : 리퀘스트와 리스폰스를 중계를 할 때 메시지 변경을 하지 않는 타입의 프록시

# 게이트웨이 
- 다른 서버를 중계하는 서버 
- 수신한 리퀘스트를 리소스를 보유한 서버인 것처러 수신
- 통신의 안정성을 높인다. 
- 게이트웨이는 데이터베이스에 접속해 SQL 쿼리를 사용해서 데이터를 얻는곳에 이용 
- 쇼핑사이트 신용카드 결제시스템등에 사용
- 

# 터널 
   - 서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 접속을 주선하는 중계프로그램
   - 통신하고 양쪽 끝의 접속이 끊어질 때 종료

# 캐시 
- 프록시 서버와 클라이언트의  로컬 디스크에 보관된 리소스의 사본을 가리킨다. 서버에 액세스를 줄이는 것이 가능하기 떄문에 통신량과 통신 시간을 절약한다. 
- 캐시를 이용함으로써 같은 데이터를 몇 번이고 오리진 서버에 전송할 필요가 없다 
- 가까운 서버로부터 리소스를 얻을 수 있게되어 서버는 같은 리퀘스트를 매번 처리하지않아도 된다.
- 

# 리퀘스트 헤더 필드 
- 리퀘스트의 부가 정보와 클라이언트의 정보 리스폰스의 콘텐츠에 관한 우선 순위 등을 추가합니다 .


# Accept 헤더필드 
- 유저 에이전트에 처리할 수 있는 미디어 탕비과 미디어타입의 상대적인 우선 순위를 전달하기 위해서 사용됩니다.

# Content -MD5 :
- 헤더 필드는 메시지 바디가 변경되지 않고 도착했는지 확인하기 위해 MD5알고리즘에 의해서 생성된 값을 전달합니다.


# Http의 약점
- 평문 통신이기 때문에 도청 가능 -> 암호화하는 기능이 없기 때문
  - TCP/IP 구조상 통신 경로의 도중에 엿볼수 있다.
  - 전부 자기가 소유하고 있지않기 때문
  - 같은 세그먼트의 통신을 도청하는 것은 어려운일이 아니다. 
  - 패킷을 수집하려면 패킷을 해석하는 캡처나 스니퍼라는 툴을 사용
  
- 통신 상대 확인하지 않기 때문에 위장 가능
  - 리퀘스트나 리스폰스에서 통신 상대를 확인하지 않는다. 
  - 누구든지 리퀘스트 할수있다.
  - 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹서버인지 아닌지를 확인할 수 없다 .
  - 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지 아닌지를 확인할 수 없다.
  - 의미없는 리퀘스트라도 수신하게 된다.
  - Dos 공격을 방지할 수가 없다.
- 
- 완전성을 증명할 수 없기 때문에 변조 가능
  - 수신한 내용이 다를지도 모른다.
  - 공격자가 도중에 리퀘스트나 리스폰스를 뺴앗아 변조하는 중간자 공격을 할수 있다.
  - MD5나 SHA-1 등의 해시값을 확인하는 방법과 디지털 서명을 확인하는 방법으로 방지


# HTTPS 
- HTTP + 암호화 + 인증 + 완정성 보호 = HTTPS 
- HTTP의 문제점을 보완 
- 암호화 인증과 완전성 보호  같은 구조를 추가했음
- HTTP 통신을 하는 소켓부분을 SSL이나 TLS이라는 프로토콜로 대체하는 것 
- 직접 TCP와 통신을 하지만 SSL을 사용한 경우에는 HTTP 는 SSL 과 통신하고 SSL이TCP와 통신하게 된다. 
- 즉 SSL 이라는 껍질을 덮어 쓴것이 HTTPS
- SSL 은 공개키 암호화 방식을 쓴다. 암호화나 복호화할때 이키를 사용 키가 없으면 아무도 암호를 못푼다.
- 공통키 암호화 방식을 사용하면 상대방에게 키를 넘겨주지 않으면 안된다.
- 그래서 나온것이 두 개의 공개키 암호
- 서로 다른 두 개의 키페어 사용 한쪽은 private key , 다른 한쪽은 public key
- 하지만 CPU나 메모리등 리소스가 많이 필요해 무조건 쓴다고 볼순 없다.
- CA에서 공개키 증명서를 구입해야함 
- 다른 암호화 하지 않은 포로톸ㄹ에도 공통되는 문제이다.


# HTTP의 병목현상
- 갱신된 정보를 가능한 빨리 실시간으로 표시하기 위해서는 서버상의 정보가 갱신되었을때 그것을 클라이언트 화면에 반영할 필요가 있다.
- 단순한 것처럼 보이지만, HTTP에서는 이 처리를 제대로 할 수가 없다.
- HTTP에서는 서버의 정보가 갱신되었는지 아닌지를 알기 위해서 클라이언트가 항상 서버 측에 확인하러 가야한다. 
- 만약 서버 상의 정보가 갱신되지 않은 경우에는 불필요한 통신이 발생하게된다. 


# WebSocket :
- 웹브라우저와 웹 서버를 위한 양방향 통신 규격으로 
- 주로 Ajax Comet에서 사용하는 XMLHttpRequest의 결점을 해결하기 위한 기술이다.
- 웹 서버와 클라이언트가 한번 접속을 확립하면 그 뒤으 통신은 모두 전용 프로토콜로하는 방식으로 JSON이나 XML,HTML이나 이미지 등 임의 형식의 데이터를 보낸다.
- 한 번 접속을 확립하면 WebSocket을 사용하여 서버와 클라이언트 어느 쪽에서도 송신할 수 있다.

# Java에서 보급된 서블릿
- 서블릿은 서버 상에 동적컨텐츠를 생성하기 위한 프로그램을 가리킴 
- 서블릿에서는 웹서버와 같은 프로세스 속에서 동작하기 때문에 비교적 부하를 적게 하여 동작시킴 
- CGI 문제점을 해결하는 
- 기술로서 Java와 함께보급됨


# TLS 
- 보안 강화: TLS는 공개 키 암호화 기술을 사용하여 통신 내용을 암호화합니다. 클라이언트와 서버 간의 통신은 세션 키를 교환하고 이를 사용하여 데이터를 암호화합니다.

- 데이터 무결성: TLS는 HMAC (Hash-based Message Authentication Code)을 사용하여 전송된 데이터의 무결성을 검증합니다. 데이터가 전송 중에 변경되지 않았는지 확인합니다.

- 상호 인증: 클라이언트와 서버는 서로의 신원을 확인할 수 있습니다. 이를 통해 중간자 공격과 같은 보안 위협을 방지할 수 있습니다.

- 다양한 암호화 알고리즘 지원: TLS는 다양한 암호화 알고리즘을 지원하며, 현재 주로 사용되는 버전인 TLS 1.2와 TLS 1.3에서는 강력한 암호화 기술을 제공합니다.






