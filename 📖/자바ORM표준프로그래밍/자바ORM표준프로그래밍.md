# JPA

## 1. 많은 쿼리를 짜다보니 객체 모델은 데이터 중심 모델로 변해갔다. 
2. 객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해주는 ORP 이것이 JPA를 사용하는 가장 큰 이유이다.

- JPA를 사용하는 개발자는 SQL을 직접 장성하는 것이 아니라 어떤 SQL이 실행될지 생각만 하면된다.
- CRUD을 작성할 필요가 없고, 조회된 결과를 객체로 매핑하는 작업도 대부분 자동으로 처리해준다. 가장 큰 장점으론 객체중심으로 개발하니 생산성과 유지보수가 확연히 좋아졌다.
- 데이터베이스에 데이터를 관리하려면 SQl을 사용해야한다. 자바로 작성한 애플리케이션은 JDBC API를 사용해서 SQL을 데이터베이스에 전달한다.

애플리케이션에서 SQL을 직접 다룰 떄 발생하는 문제점은 
- 진정한 의미의 계층 분할이 어렵다
- 엔티티를 신뢰할 수 없다.
- SQLdㅔ 의존적인 개발을 피하기 어렵다
- SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다. 
- 이것은 개발자에게 너무 큰 제약이다 
- 비즈니스 로직에 따라 사용하는 객체 그래프가 다른데 언제끊어질지 모를 객체 그래프를 함부로 탐색할 수 는 없기 떄문이다.

JPA는 연관된 객체를 신뢰하고 마음껏 조회 할 수 있다.
    - ***  이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고해서 지연 로딩 이라고한다.


정리 :객체 모델과 데베모델은 지향하는 패러다임이 서로 다르다. 
정교한 객체 모델링을 할수록 패러다임의 불일치 문제가 더 커진다.
그것을 극복하기 위한 결과물이 JPA다. 


ORM 프레임워크가 애플리케이션을 객체지향적으로 개발할 수 있도록 도와주긴하지만 결국 관계형 데이터베이스에 저장된다. 그러므로 
SQL도 잘알아햔다. ORM프레임워크를 사용할 때 가장 중요한일은 객체와 테이블을 매핑하는 것이다. 매핑을올바르게 하려면 객체와 관계형 데이터베이스 양쪽을 모두 
이해해야 한다. 


##### 95페이지 까지의 기록 


# 영속성 컨텍스트 
- 엔티티를 식별자 값 @Id로 구분
- 식별자값이 반드시 있어야한다. 
- JPA는 보통 트랜잭션을 커밋하는 순간 새로 저장된 엔티티를 데이터베이스에 반영한다 () -> Flush
- 장점 :
  - 1차 캐시 
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  -  지연 로딩


# 엔티티 조회
- 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라고함 
- 영속상태의 엔티니는 모두 이곳에 저장 
- 내부에 Map이하나 있는데 키는 @Id로 매핑한 식별자고 값은 엔티티 인스턴스
- Member member = em.find(Member.class, "member1" ) 클래스에서 member1 을찾는거임 


# 변경 감지 기능 
- 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능
- 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시 호출
- 스냅샷을 비교해서 변경된 엔티티를 찾는다
- 수정쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.
- 트랜잭션 커밋
- 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용


!! 영속성 컨텍스트에 보관된 엔티티를 지운다고생각 X !!
영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것이 플러시다!!


# IDENTITY 
- 엔티티가 영속 상태가 되려면 식별자가 반드시 필요 
- 식별자 생성 전략은 데베에 저장해야 식별자를 구할 수 있으므로 
- em.persist()를 호출하는 즉시 데베에 전달된다. 그래서 쓰기지연이 동작하지않음 !!

# 단뱡향과 양방향
- 단뱡향 매핑으로 테이블과 객체의 연관관계 매핑은 이미 완료되었다.
- 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가됨
- 매핑하려면 객체에서 양쪽방향을 모두 관리해야한다.
- 연관관계 주인은 외래 키의 위치와 관련해서 정해야지 비즈니스 중요도로 접근하면 xxxx

양방향 매핑시 무한루프에 빠지지않게 조심해야한다. 

# 일대다 
- 일대다 관계는 다대일 관계의 반대 방향이다. 일대다 관계는 엔티티를 하나 이상 참조할 수이ㅣㅆ으므로 
- Collection, List, Set, Map 중에 하나를 사용
- 일대다 단뱡향의 단점 
  - 매핑한 객체가 관리하는 외래키가 다른 테이블에 있다.
  - 본인 테이블에 외래 키가 있으면 엔티티의 저장과 연관관계처리를 한번에 끝내지만 
  - 다른테이블에 외래 키가 있으면 연관관계 처리를 위한 UPDATE SQL 추가로실행해야한다,

# OneToMany @ManyToOne
- 일대 다 양방향 매핑은 사실상 존재하지않는다. 
- 대신 다대일 양방향 매핑을 사용해야한다
- 양방향 매핑에서 원투매니는 연관관계의 주인이 될 수없다.
- 다대일 관계는 항상 다쪽에 외래 키가 있다.
- 그렇다고 일대다 양방향 매핑이 완전히 불가능한것은 아니다. 
- 단방향 매핑을 읽기 전용으로 하나 추가하면된다.
- 



# 단일 테이블 전략
- 구분 컬럼을 꼭사용해야한다. 따라서 @DiscriminatorColumn을 꼭 설정
- 기본으로 엔티티이름을 사용한다.
- 
- 장점: 
- 테이블을 하나만 사용하는것 
- 조인을 사용하지않으므로 일반적으로 가장 빠름
- 조회 쿼리가 단순하다.

- 단점 :
- 자식 엔티티가 매핑한 컬럼은 모두 null허용 해야한다,.
- 단일 테이블에 모든 것을 저장하므로 테이블이 커짐
- 상황에 따라서는 조회성능이 오히려 느려질수있다.



# 구현 클래스마다 테이블 전략
- 서브 타입을 구분해서 처리할 떄 효과적이다. 
- not null제약조건을 사용 가능

- 여러 자식 텡비르을 함께조회할 때 성능이 느리다. UNION 사용해야함
- 자식 테이블을 통합해서 쿼리하기 어렵다.


# 식별관계 VS 비식별관계
- DB 와 Tabel 사이에 관계는 외래키와 기본 키에 포함되는지 여부에 따라 식별관계와 비식별관계로 구분한다.
- 식별관계 : 
  - 부모테이블기본키를 내려받아서 자식 테이블의 기본 키 + 외래키로 사용하는 관계
  - 부모테이블의 기본키를 자식 테이블로 전파하면서 자식테이블의 기본 키 컬럼이 점점 늘어난다.
  - 결국 조인할 떄 SQL이 복잡해지고 기본 키 인덱스가 불필요하게 커진다.
  - 2개 이상으 ㅣ컬럼을 합해서 복합 기본 키를 만들어야 하는 경우가 많다.
  - 비즈니스 의미가 자연 키 컬럼을 조합하는 경우가 많다. 반면에 비식별 관계의 기본 키는 시간이 지남에 따라 언젠가는 변한다. 자연 키 컬럼들이 자식에 손자까지 전파되면 변경하기 어렵다 .
  - 부모 테이블의 기본 키를 자식 테이블의 기본 키로 사용하므로 비식별 관계보다 테이블 구조가 유연하지 않다 .
  - 
  
- 비식별관계 :
  - 부모테이블의 기본 키를 받아서 자식 테이블의 외래키로만 사용하는 관계다.

- 필수적 비식별관계 : 외래 키에 NULL을 허용하지 않는다. 연관관계를 필수적으로 맺어야한다. 
- 선택적 비식별관계 : 외래키에 NULL을 허용한다. 연관관계를 맺을지 말지 선택 가능
- JPA에서는 모두 지원한다. - > 그래서 꼭 필요한 곳에만 식별관계를 사용하는 추세다 
- 결국엔 추천하는 방법은 될 수 있으면 비식별관계를 사용하고 기본 키는 Long 타입의 대리 키를 사용하는 것이다. 
- 대리 키는 비즈니스와 아무 관련이 없다. 따라서 비즈니스가 변경되어도 유연한 대처가 가능하다는 장점이 있다. 

- > 객체 상속 관계를 데이터베이스에 매핑하는 방법을 학습했고, 
  > 다음으로 매핑 정보만 상속하는 방법을 알아봤고, 테이블은 보통 외래키로 연관관계를 맺는데 조금 더 복잡화지만 더 유연한 연결 테이블을 두고 매핑하는 조인테이블을 알아보았다. 
  > 


# 프록시와 연관관계 매핑 
- 프록시 : 엔티티를 조회할 떄 연관된 엔티티들이 항상 사용 되는 것은 아니다. 
- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라고 한다. 

# 프록시 초기화 과정 
1. 프록시 객체에 member.getName()을 호출해서 실제 데이터를 조회한다.
2. 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티생성을 요청하는데 이것을 초기화라고 한다.
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 멤버변수에 보관한다. 
5. 프록시 객체는 실제 엔티티 객체의 getName()을 호출해서 결과를 반환한다. 

# 프록시 특징 :
- 처음 사용할 떄 한번만 초기화
- 프록시 객체를  초기화 한다고 해서 실제 엔티티로 바뀌는 것은 아니다.  프록시 객체를 통해서 실제 엔티티에 접근 할 수 있다.
- 원본 엔티티를 상속받은 객체이므로 타입 체크시에 주의해서 사용
- 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 프록시가 아닌 실제 엔티티를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다. 

 - 조회한 엔티티가 진짜 엔티티인지 프록시로 조회한 것인지 확인하려면 클래스 명을 직접 출력해보면된다.
 - 주로 엔티티를 지연 로딩할 때 사용한다.


- 즉시 로딩 : 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
  - ManyToOne 의 fetch 속성을 FetchType.EAGER로 설정한다. 
  - 회원을 조회하는 순간 팀도 함께 조회 
  - 두 테이블을 조회 하므로, 쿼리를 2번 실행 한것 같지만 대부분의 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인쿼리를 사용한다.
  
- 지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다.
  - ManyToOne 속성에 fetch속성을 FetchType.LAZY로 지정한다.
  - em.find(member.class,"member1")
  - 호출하면 회원만 조회하고 팀은 조회하지 않는다. 
  - 멤버 변수에 프록시 객체르 넣어둔다. 실제 사용될 떄 까지 데이터 로딩을 미룬다.
  - 실제 데이터가 필요한 순간이 되어서야 데이터베이스를 조회해서 프록시 객체를 초기화한다. 

- 컬렉션에 FetchType.EAGER 사용할 경우에 주의할 점은 
- 하나 이상 즉시 로딩하는것을 권장하지 않는다. 컬렉션과 조인한다는 것은 데이터베이스 테이블로 보면 일대다 조인이다. 따라서 2개이상의 컬렉셩느 즉시 로딩으로 설정하는것은 권장x
- 즉시 로딩은 항상 외부조인을 사용한다. 
- JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태어야한다. 
- 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화는 편리함을 제공할 뿐


 # 정리 
- JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 지원하는데  ()- > 이때 프록시 기술 사용
- 객체를 조회할 때 연관된 객체를 즉시 로딩하는 방법을 즉시로딩이라고하고, 
- 연관된 객체를 지연해서 로딩하는것을 지연 로딩이라고 한다.
- 객체를 저장하거나 삭제할 때 연관된 객체와 함께 저장하거나 삭제할 수 있는데 이것을 영속성 전이
- 부모 엔티티와 관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 제거 기능을 사용하면된다.



# 값 타입 
- JPA에서 데이터 타입을 가장 크게 분류하면





