# JPA

## 1. 많은 쿼리를 짜다보니 객체 모델은 데이터 중심 모델로 변해갔다. 
2. 객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해주는 ORP 이것이 JPA를 사용하는 가장 큰 이유이다.

- JPA를 사용하는 개발자는 SQL을 직접 장성하는 것이 아니라 어떤 SQL이 실행될지 생각만 하면된다.
- CRUD을 작성할 필요가 없고, 조회된 결과를 객체로 매핑하는 작업도 대부분 자동으로 처리해준다. 가장 큰 장점으론 객체중심으로 개발하니 생산성과 유지보수가 확연히 좋아졌다.
- 데이터베이스에 데이터를 관리하려면 SQl을 사용해야한다. 자바로 작성한 애플리케이션은 JDBC API를 사용해서 SQL을 데이터베이스에 전달한다.

애플리케이션에서 SQL을 직접 다룰 떄 발생하는 문제점은 
- 진정한 의미의 계층 분할이 어렵다
- 엔티티를 신뢰할 수 없다.
- SQLdㅔ 의존적인 개발을 피하기 어렵다
- SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다. 
- 이것은 개발자에게 너무 큰 제약이다 
- 비즈니스 로직에 따라 사용하는 객체 그래프가 다른데 언제끊어질지 모를 객체 그래프를 함부로 탐색할 수 는 없기 떄문이다.

JPA는 연관된 객체를 신뢰하고 마음껏 조회 할 수 있다.
    - ***  이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고해서 지연 로딩 이라고한다.


정리 :객체 모델과 데베모델은 지향하는 패러다임이 서로 다르다. 
정교한 객체 모델링을 할수록 패러다임의 불일치 문제가 더 커진다.
그것을 극복하기 위한 결과물이 JPA다. 


ORM 프레임워크가 애플리케이션을 객체지향적으로 개발할 수 있도록 도와주긴하지만 결국 관계형 데이터베이스에 저장된다. 그러므로 
SQL도 잘알아햔다. ORM프레임워크를 사용할 때 가장 중요한일은 객체와 테이블을 매핑하는 것이다. 매핑을올바르게 하려면 객체와 관계형 데이터베이스 양쪽을 모두 
이해해야 한다. 


##### 95페이지 까지의 기록 


# 영속성 컨텍스트 
- 엔티티를 식별자 값 @Id로 구분
- 식별자값이 반드시 있어야한다. 
- JPA는 보통 트랜잭션을 커밋하는 순간 새로 저장된 엔티티를 데이터베이스에 반영한다 () -> Flush
- 장점 :
  - 1차 캐시 
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  -  지연 로딩


# 엔티티 조회
- 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라고함 
- 영속상태의 엔티니는 모두 이곳에 저장 
- 내부에 Map이하나 있는데 키는 @Id로 매핑한 식별자고 값은 엔티티 인스턴스
- Member member = em.find(Member.class, "member1" ) 클래스에서 member1 을찾는거임 


# 변경 감지 기능 
- 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능
- 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시 호출
- 스냅샷을 비교해서 변경된 엔티티를 찾는다
- 수정쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.
- 트랜잭션 커밋
- 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용


!! 영속성 컨텍스트에 보관된 엔티티를 지운다고생각 X !!
영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것이 플러시다!!


# IDENTITY 
- 엔티티가 영속 상태가 되려면 식별자가 반드시 필요 
- 식별자 생성 전략은 데베에 저장해야 식별자를 구할 수 있으므로 
- em.persist()를 호출하는 즉시 데베에 전달된다. 그래서 쓰기지연이 동작하지않음 !!

# 단뱡향과 양방향
- 단뱡향 매핑으로 테이블과 객체의 연관관계 매핑은 이미 완료되었다.
- 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가됨
- 매핑하려면 객체에서 양쪽방향을 모두 관리해야한다.
- 연관관계 주인은 외래 키의 위치와 관련해서 정해야지 비즈니스 중요도로 접근하면 xxxx

양방향 매핑시 무한루프에 빠지지않게 조심해야한다. 

# 일대다 
- 일대다 관계는 다대일 관계의 반대 방향이다. 일대다 관계는 엔티티를 하나 이상 참조할 수이ㅣㅆ으므로 
- Collection, List, Set, Map 중에 하나를 사용
- 일대다 단뱡향의 단점 
  - 매핑한 객체가 관리하는 외래키가 다른 테이블에 있다.
  - 본인 테이블에 외래 키가 있으면 엔티티의 저장과 연관관계처리를 한번에 끝내지만 
  - 다른테이블에 외래 키가 있으면 연관관계 처리를 위한 UPDATE SQL 추가로실행해야한다,

# OneToMany @ManyToOne
- 일대 다 양방향 매핑은 사실상 존재하지않는다. 
- 대신 다대일 양방향 매핑을 사용해야한다
- 양방향 매핑에서 원투매니는 연관관계의 주인이 될 수없다.
- 다대일 관계는 항상 다쪽에 외래 키가 있다.
- 그렇다고 일대다 양방향 매핑이 완전히 불가능한것은 아니다. 
- 단방향 매핑을 읽기 전용으로 하나 추가하면된다.
- 



# 단일 테이블 전략
- 구분 컬럼을 꼭사용해야한다. 따라서 @DiscriminatorColumn을 꼭 설정
- 기본으로 엔티티이름을 사용한다.
- 
- 장점: 
- 테이블을 하나만 사용하는것 
- 조인을 사용하지않으므로 일반적으로 가장 빠름
- 조회 쿼리가 단순하다.

- 단점 :
- 자식 엔티티가 매핑한 컬럼은 모두 null허용 해야한다,.
- 단일 테이블에 모든 것을 저장하므로 테이블이 커짐
- 상황에 따라서는 조회성능이 오히려 느려질수있다.



# 구현 클래스마다 테이블 전략
- 서브 타입을 구분해서 처리할 떄 효과적이다. 
- not null제약조건을 사용 가능

- 여러 자식 텡비르을 함께조회할 때 성능이 느리다. UNION 사용해야함
- 자식 테이블을 통합해서 쿼리하기 어렵다.


