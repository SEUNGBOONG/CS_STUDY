
# Domain Driven Design 

- 개발자 입장에서 보면 온라인 서점은 구현해야할 소프트웨어의 대상이다. 
- 책을 판매하는데 필요한 상품 조회 구매 결제 배소우적등의 기능을 제공해야한다.
- 한 도메인은 다시 하위 도메인으로 나눌수 있다.


전문가와 개발자 간 지식공유: 
온라인 홍보 정산 배송등 각영역에는 전문가가 있다. 이들 전문가는 해당 도메인에 대한 지식과 경험을 바탕으로 본인들이 원하는 기능 개발을 요구한다.
예를 들어 회계 담당자는 엑셀로 맞추던 정산금액 게산을 자동화해주는 기능을 요구할 수 있다. 
이런 요구사항을 분석하고 설계하여 코드를 작성하며 테스트하고 배포한다. 
이 과정에서 요구사항은 첫단추이다 .

그래서 코딩에 앞서 요구사항을 올바르게 이해하는 것이 중요하다. 
요구사항을 제대로 이해하지 않으면 쓸모없거나 유용함이 떨어진다.

개발자와 전문가가 직접 대화하는 것이 제일 좋다.

Garbage in GarBage out 찾아보기 

도메인 모델에는 다양한 정의가 존재한다. 
기본적으로 도메인 모델은 특정 도메인을 개념적으로 표현한 것이다. 
도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 이해하고 도메인 지식을 공유하는데 도움이 된다.

모델을 표현할 때 클래스 다이어그램이나 상태 다이어그램과 같은 UML 표기법만 사용해야 하는 것은 아니다. 
관계가 중요한 도메인이라면 그래프를 이용해서 도메인을 모델링할 수 있다.

인프라스트럭처: Infrastructure : 데이터베이스 메시징 시스템과 같은 외부시스템과의 연동을 처리한다.

도메인 모델 : 도메인 자체를 표현하는 개념적인 모델을 의미하지만, 도메인 계층을 구현할 때 사용하는 객체 모델을 언글할 때에도 도메인 모델이란 용어를 사용한다.

도출한 모델은 크게 엔티티와 밸류로 구분할 수 있다. 
이것을 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문이다. 

엔티티: 가장 큰 특징은 식별자를 가진다는 것이다. 
객체마다 고유해서 각엔티티는 서로 다른 식별자를 갖는다. 
고유하기 때문에 두엔티티 객체의 식별자가 같으면 두엔티티는 같다고 판단할 수 있다.

흔히 식별자는 
특정 규칙에 따라 생성
UUID
값을 직접입력
일련번호 사용 등으로 생성한ㄴ다.

자바는 import.java.util.UUID 클래스를 사용할수 있다.


밸류 타입은 개념적으로 완전한 하나를 표현할 때사용한다. : VO 필드는 여러개가능 


도메인 모델에는 set메서드 넣지않기 
겟셋 메서드를 습관적으로 추가할때가 있다. 
## 무조건 추가하는 것은 좋지 않은 버릇이다. 특히 셋메서드는 도메인의 핵심개념이나 의도를 코드에서 사라지게한다.

private 일때 외부에서 데이터를 변경할 목적으로 set메서드를 사용할 수 없다.
불변 밸류타입을 사용하면 자연스럽게 밸류타입에는 셋메서드를 구현하지않는다.

DTO :Data Transfer Object 의 약자로 프레젠테이션 계층과 도메인 계층이 데이터를 서로 주고받을 때 사용하는 일종의 구조체이다. 



표현 영역은  웹브라우저가 HTTP요청 파라미터로 전송한 데이터를 응용 서비스가 요구하는 형식 객체타입을 ㅗ변환해서 잔달하고 응용 서비스가 리턴한 결과를 JSOn형식으로 변호나해서 HTTP응답으로 웹브라우저에 전송한다.
응용 서비스는 로직을 직접 수행한다기보단 도메인 모델에 로직 수행을 위임한다. 

인프라스트럭처 영역은 구현기술에 대한 것을 다룬다 이영역은 RDBMS 연동을 처리하고 메시징 큐에 메시지를 전송하거나 수신하는 기능을 구현하고 몽고디비 레디스와 의 데이터연동을 처리한다.
SMTP를 이용해 메일 발송 기능을 구현하거나 HTTP 클라이언트를 이용해서 REST API를 호출하는 것도 처리한다. 
논리적인 개념을 표혆사기보다는 실제 구현을 다룬다. 


인프라스트럭처에 의존하면 테스트 어려움과 기능 확장의 어려움이라는 두 가지 문제가 발생한다. 
이것을 DIP로 해결한다. 
저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. 고수준 모듈을 구현하려면 저수준 모듈을 사용해야 하는데, 반대로 저수준 모듈이 고수준 모듈에 의존하도록하려면 어떻게해야할까 
비밀은 추상화한 인터페이스에 있다.

고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야하는데 반대로 저수준이 모듈이 고수준 모듈에 의존한다고 해서 이를 DIP  의존역전원칙이라고 부른다.

DIP를 적용하면 앞의 다른 영역이 인프라스트럭처 영역에 의존할 때 발생헀던 두 가지 문제인 구현 교체가 어렵다는 것과 테스트가 어려운 문제를 해소할 수 있다.

애그리거터는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다. 
내부구현을 숨겨서 애그리거트 단위로 구현을 캡슐화 할 수 있도록 돕는다.

복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있ㄷ는 방법이 필요하다. 그 방법이 바로 애그리거트 
관련된 객체를 하나의 군으로 묶어준다.
모두 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이책임을 지는 것이 바로 애그리거트의 루트 엔티티이다.

트랜잭션의 범위는 작을수록 좋다. 한 트랜잭션이 한개 테이블을 수정하는 것과 세개의 테이블을 수정하는 것을 비교하면 성능에서 차이가 발생한다.
한트랜잭션에서는 한개의 애그리거트 만 수정해야하낟.
애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화 해야한다.

리포지터리가 완전한 에그리거트를 제공하지 않으면 필드나 값이 올바르지않아 애그리거트의 기능을 실행하는 도중에 널포인트 익셉션 과 같은 문제가밠애한다.



# 스프링 데이터 JPA를 이용한 조회 가능 
CQRS : 명령 모델과 조회 모델을 분리하는 패턴이다. 
명령 모델은 상태를 변경하는 기능을 구현할 때 사용하고 조회 모델은 데이터를 조회하는 기능을 구현할 떄 사용한다. 
예를 들어 회원 가입 암호변경 주문취소 데이터를 조회하는 기능을 구현할 때 사용한다.
엔티티 애그리거트 리포지터리 등 앞에서 살펴봤던 모델은 주문취소 배송지 변경과 같은 조회 기능에 사용된다


스프링 데이터 JPA가 제공하는 스펙 인터페이스는 스펙을 조합할 수 있는 두메서드를 제공하고있다.

스프링 jpa는 두가지 방법을 사용해서 정렬을 지정할 수 있다.
find 메서드는 OrderBy를 사용해서 정렬 순서를 지정할 수 있다.

두 개 이상의 프로퍼티에 대한 정렬 순서를 지정할 수도 있다. 
메서드 이름에 오더바이를 사용하는 방법은 간단하지만 정렬 기준 프로퍼티가 두 개 이상이면 메서드 이름이 길어지는 단점이 있다. 또한 메서드 이름으로 정렬 순서가 
정해지기 떄문에 상황에 따라 정렬 순서를 변경할 수도 없다. 이럴 때는 Sort 타입을 사용하면된다.

find 메서드에 마지막 파라미터로 Sort를  추가했다. 스프링 데이터 JPA 는 파라미터로 전달 받은 Sort 를 사용해서 알맞게 정렬 쿼리를 생성한다. 


# 페이징 처리하기 
목록을 보여줄 때 전체데이터중 일부만 보여주는 페이징처리 
Pageable 타입을 사용한다. 
 결국에는 데이터 속도를 높이는게 아니라 프런트엔드에서 확인하기 쉽게 하는 것 같음 


# 표현 영역과 응용 영역
 도메인을 잘만든다고 끝나는 것이 아니다 도메인이 제 기능을 하려면 사용자와 도메인 을 연결해 주는 매개체가 필요하다. 2장 아키텍처에서 설명한 응용 영역과 표현 영역이
 사용자와 도메인을 연결해주는 매개체 역할을 해준다.


 Human - > 표현 영역 - > 응용 영역 - > 도메인 영역

1. 표현영역은 사용자의 요청을 해석한다. - > 사용자가 웹브라우저에서 폼에 ID와 암호를 입력한 뒤에 전송 버튼을 클릭하면 요청 파라미터를 포함한 HTTP 요청을 표현 영역에 전달한다.
2. 표현영역은 URL, 요청 파라미터, 쿠키 , 헤더 등을 이용해서 사용자가 실행하고 싶은 기능을 제공하는 응용 서비스를 실행한다. 
3. 실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 서비스다. 사용자가 회원 가입을 요청했다면, 실제 그 요청을 위한 기능을 제공하는 주체는 응용 서비스에 위치힌다. 
4. 필요한 입력 값을 메서드 인자로 받고 실행 결과를 리턴한다.
5.  응용 서비스는 메서드가 요구하는 파라미터와 표현 영역이 사용자로부터 전달받은 데이터는 형식이 일치하지 않기 떄문에 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환한다.
6. 사용자 요청에 맞게 HTMl 이나 JSon형식으로 응답할 것이다. 
7. 사용자가 웹 브라우저를 사용하는지 REST API 를 호출하는지 TCP 소켓을 사용하는지를 알 필요가 없다. 단지 기능 실행에 필요한 입력 값을 받고 실행 결과만 리턴하면 될 뿐이다. 
 

응용 서비스는 사용자가 요청하는 기능을 실행한다. 
도메인 객체를 사용해서 사용자의 요청을 처리하는 것이므로 표현 영역입자에서 보았을 때 응용 서비스는 도메인영역과 표현 영역을 연결해주는 창구 역할을 한다.

트랜잭션 처리도 담당한다. 

도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다. 
응집성이 떨어지고, 동일한 기능을 다른곳에서도 구현해놓을 가능성이 높다. 

응용 서비스 자체의 구현은 어렵지 않다 .
하지만 고민해야 할 것이 있다.
1. 회원가입하기, 탈퇴하기 암호 변경하기 초기화하기와 같은 기능을 구현하기 위해 도메인 모델을 사용하게 된다. 이 경우 응용 서비스는 보통 다음의 두 가지 방법 중 한 가지 방식으로 구현한다.
2. 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
3. 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기


한 클래스에 코드가 모이기 시작하면 엄연히 분리하는 것이 좋다 하지만 습관적으로 기존에 존재하는 클래스에 끼워 넣게 되는데 품질을 낮춘다.
클래스가 많아지더라도 품질을 일정 수준으로 유지해라 

응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편하겠지만 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게된다.
응집도를 낮춰버린다.
# 표현 영역에서 필요한 데이터 만 리턴하는 것이 기능 실행 로직의 응집도를 높이느 확실한 방법이다.


트랜잭션처리 : 
회원가입에 성공했다고 해도 회원 정보를 디비에 저장하지 않으면 로그인을 할 수 없다 .
트랜잭션을 관리하는 것을 응용 서비스의 중요 역할이다. 

스프링에서 제공하는 트랜잭션 기능을 적극 사용하는 것이 좋다 .

# 표현 영역에서 필수 값과 값의 형식을 검사하면 실질적으로 서비슨느 ID 중복여부와 같은 논리적 오류만 검사하면된다.
결론: 
- 표현 영역 :필수 값 값의 형식 범위 등을 검증한다 -> 여기서 스스로에게 던지는 질문 표현 영역에서 원시값을 포장해서 사용하나 .. ?
- 응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류를 검증한다. 



도메인 서비스 객체를 애그리거트에 주입하지 않기 
메서드를 실행할 때 도메인 서비스 객체를 파라미터로 전달한다는 것은 애그리거트가 도메인 서비스에 의존한다는 것을 의미한다. 
스프링 DI와 AOP를 공붛다ㅏ 보면 애그리거트가 의존하는 도메ㅐ인 서비스를 의존 주입으로 처리하고 싶을 수 있다. 관련 기술에 빠져있으면 특히 그렇다.
프레임워크가 제공하는 의존 주입 기능을 사용해서 도메인 서비스를 애그리거트에 주입해야 길수적으로 나은 것 같은 착각도 하게된다.
