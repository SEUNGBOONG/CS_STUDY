JAVA 공부를 위해 추천을 받은 책이다.
읽었던 부분에 대해 감명깊은 부분을 기록해두기

서문

객체지향에 대해 원론적으로만 알고있었지만, 한 단계 이해도를 성장을 목표로 책을 읽었습니다.
객체지향으로 향한는 첫 걸음은 클래스가 아니라 객체를 바라보는 것으로 시작한다.

두번째는 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 존재로 바라보는 것이다.

세번째 걸음을 내디딜 수 있는지 여부는 협력에 참여하는 객체들에게 얼마나 적절한 역할과 책임을 부여할 수 있느냐

마지막 걸음은 앞에서 설명한 개념들을 프로그래밍 언어라는 틀에 흐트러짐 없이 담아낼 수 있는 기술을 익히는것이다.

협력하는 객체들의 공동체

실세계를 모방하는 것이 아니라 새로운 세계를 창조하는 것에 초점을 두고 설명을 하고 있다.

객체를 스스로 생각하고 스스로 결정하는 현실 세계의 생명체에 비유하는 것은 상태와 행위를 캡슐화하는 소프트웨어 객체의 자율성을 설명하는데 효과적이다.

커피 공화국의 아침

커피를 주문하고 커피를 받아가는 과정까지 이 작은 이벤트를 토대로 객체를 설명해주셨다.

커피를 주문하고 제조하는 과정은 역할, 책임, 협력이라는 사람의 일상 속에 항상 스며들어 있는 세 가지 개념이 한데 어울려 조화를 이루며 만들어 낸 것이다.

커피를 사고 돌아가는 과정 속에 손님, 캐셔, 바리스타 사이의 암묵적인 협력 관계가 존재한다. 손님에게 커피를 내주기 전까지 협력하는 과정 속 자신이 맡은 바 책임을 다함으로써 완벽한 커피를 제공할 수 있게된다.

소프트웨어도 똑같다. 사람사는 곳이라면 어디서나 역할 책임 협력이 존재한다.

즉 객체지향에서는 가장 중요한 것이 역할, 책임, 협력이다.

역할은 어떤 협력에 참여하는 특정한 사람이 협력 안에서 차지하는 책임이나 의무이다. 역할이란 단어는 의미적으로 책임이라는 개념을 내포한다.

- 여러 사람이 동일한 역할을 수행할 수 있다.

손님 입장에선 커피를 주문할 수 있다면, 어떤 캐셔가 오든 어떤 바리스타가 오든 상관이 없다.

-역할은 대체 가능성을 의미한다.

손님 입장에서 캐셔는 대체가능하다. 두 명이 동일한 역할을 수행할 수 있다면, 문제가 되지않는다.

-책임을 수행하는 방법은 자율적으로 선택가능 (다형성)

-한 사람이 동시에 여러 역할을 수행할 수 있다.

캐셔와 바리스타라는 개별적으로 나눴지만 사실 캐셔가 바리스타 역할 역시 할 수 있는 것이다.

이것을 투영해서 설명하면 사람이라는 단어를 객체로 에이전트의 요청을 메시지로 요청을 처리하는 방법은 메서드로 바꾸면 마법처럼 객체지향이 된다. 결국 객체지향을 표현하기위해 실세계를 모방한것이다.

실행중인 객체지향 애플리케이션의 내부를 들여다볼 수 있다면, 겉으로는 우리가 알고 있는 세계와 유사해 보이지만, 본질적으로는 매우 이질적인 모습을 지닌 세계와 마주치게 될 것이다.

객체지향의 세계에서 모든 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다.

엘리스 객체의 키를 작게만드는 것이 엘리스 자신인 것처럼 음료객체의 양을 줄이는 것은 음료 자신이어야한다.

앨리스가 음료를 마셔 키를 작게 만든다. 따라서 엘리스 자신의 상태를 변경한다. 이 과정에서 음료 객체에게 자신이 먹은 양만큼 음료의 양을 줄여달라 요청한다. 양을 줄이는 것은 음료 객체 스스로 결정할 사항이다.

최종적으로

- 객체는 상태를 가지며 상태는 변경 가능하다.

- 객체의 상태를 변경시키는 것은 객체의 행동이다.

행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
행동의 순서가 실행 결과에 영향을 미친다.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.

객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정

상태를 중심으로 객체를 바라보는 것이다. 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.

먼저 상태를 먼저 결정할 경우 캡슐화가 저해된다. 상태가 객체 내부로 깔끔하게 캡슐화 되지 않고 공용인터페이스에 그대로 노출 되버릴 확률이 높아진다.

둘쨰, 객체를 협력자가 아닌 고립된 섬으로 만든다. 객체가 필요한 이유는 "협력" 떄문인데, 상태를 먼저 고려하면 협력이라는 문맥에서 멀리 벗어난다.

셋째, 재사용성이 저하된다.

결국 좋은 객체 지향 프로그래밍을 만들려면 상태가 아니라 행동에 초점을 맞춰야 한다.

따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다.

책임 주도 설계는 협력이라는 문맥안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용성이 높은 객체를 만들 수 있다.

결국 가장 중요한 것은 행동이 상태를 결정한다 라는 것이다.

사실상 객체 지향 프로그래밍을 공부 하면서 가장 이해도가 부족했던 것은 추상화 였다. 그래서 추상화에 대한 내용을 조금 더 심도리있게 읽은 것 같다.

직관적인 분류는 추상화를 위한 훌륭한 도구가 될 수 있다라는 것을 말하고있는데, 구체적인 사물 간의 공통점을 취하고 차이점은 버리는 일반화를 통해 단순화하는 것이다. 개념을 통해 객체를 분류하는 과정은 추상화의 두 가지 차원을 모두 사용한다.

결국에는 추상화를 지켜가며 객체를 캡슐화하고, (고려 대상이라는 사실은 외부에 데이터를 감추기

역할
재판이라는 프로그램에 판사는 재판을 하는 역할을 수행하고, 토끼는 증인을 불러오는 역할만을 수행한다. 토끼가 갑자기 판사아ㅢ 역할을 대신할 수 없는것이다.


5/15 까지의 내용 

협력의 추상화
역할의 가장 큰 가치는 하나의협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다는 것이다.
설계자가 다뤄야 하는 협력의 개수를 줄이는 동시에 구체적인 객체를 추상적인 역할로 대체함으로써 협력의 양상을 단순화한다.
왕 - > 하얀 토끼 - > 모자 장수
왕 -> 하얀 토끼 - > 요리사
이러한 과정처럼 왕 하얀토끼 라는 객체를 재사용하면서 사용한다.
이것은 대체가능성에서 비롯된다.
객체가 역할을 대체하기 위해서는 행동이 호환돼야 한다. 역할이 확실하게 정해져야한다는 것이다.
협력을 설계한다는 것은 설계에 참여하는 객체들이 주고 받을 요청과 응답의 흐름을 결정한다는 것을 의미한다.
이렇게 결정된 요청과 응답의 흐름은 객체가 협력에 참여하기 위해 수행될 책임이 된다.

책임주도설계
협력에 필요한 책임을 적절하게 객체에게 할당하는 것

디자인 패턴
특정 문제를 해결하기 위해 이미 식별해 놓은 역할 책임 협력의 모음
패턴을 알고있다면 바퀴를 반복적으로 발명할 필요가 없다 .

TDD 테스트 주도 설계
테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식을 따른다.
이름에서 풍기는 뉘앙스와 달리 테스트 주도 개발은 테스트가아니라 설계를 위한 기법이다.

책임과 분산 효과
사건에 대한 목격자가 많으면 많을 수록 개인이 느끼는 책임감은 적어진다. -> 객체지향에게도 적용
객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문
적절한 책임과 적절한 객체에게 할당하는 과정 속에서 드러난다.

자율적인 책임
이부분이 가장 와닿았던 것 같다.
왕이 모자장수에게 증언을 할것을 요청했지만 어떤식으로 증언을 할지는 모자장수의 마음인 것 처럼 객체도 그렇게 생각하라는 내용인데,
객체가 무엇을 어떻게 증언할지도 결정을 해놔야 객체지향이라고 생각했던 점을 수정할 수 있었다.
즉 재판하라 - > 목격했던 장면을 떠올리고, 떠오르는 기억을 시간 순서대로 하거라 x
재판하라 - > 증언해라 로 끝나게끔 해야한다는 것이다.
How 가 아닌 what인 것이다.


5/31 까지의 내용 


객체가 어떤 메시지를 수신하고 처리할 수 있느냐가 책임을 결정한다. 
책임 주도 개발에서는 What who 사이클에 따라 협력에 참여할 객체를 결정하기 위한 메시지를 먼저 결정한다.

책임 주도 설계는 객체가 아니라 객체들이 주고받는 메시지에 초점을 맞추게 함으로써 객체지향의 장점을 극대화한다.
what / who 사이클은 어떤 객체가 필요한지를 생각하지말고 어떤 메시지가 필요한지를 먼저 고민하라고 조언한다.
메시지를 결정하기 전까지는 객체에 관해 고민하지 말아야한다.
메시지가 결정된 후에는 이메시지를 처리할 객체를 선택한다.

메시지를 믿어라, 그러면 자율적인 책임은 저절로 따라올것이다.

인터페이스 특징 
1. 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할수있다.
   - 자동차가 내부적으로 어떻게 구성돼 있고 어떤원리로 움직이는지 몰라도운전자는 운전하는데 무리가없다.  
   - 즉 운전에 필요한 기본 동작만 노출시키면된다.
2. 자체는 변경하지 않고 단순히 내부 구성이나 작동방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
   - 자동차 내부를 변경한다고해도, 운전방식이 달라지지않는다.
3. 대상이 변경되더라도 동일한 인터페이스를 제공하기만해도 아무런 문제없음
   - 한 자동차를 운전할줄 안다면 다른 자동차도 쉽게한다.

인터페이스와 구현의 분리 
훌륭한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다. 
이것은 객체를 설계할 때 객체 외부에 노출되는 인터페이스와 객체의 내부에 숨겨지는 구현을 명확하게 분리해서
고려해야 한다는 것을 의미한다.
책임이 자유로울수록 변경에 의해 수정돼야 하는 범위가 좁아지고 명확해진다. 객체지향 커뮤니티의 전문 용어로 표현하자면 변경의 파급효과가 객체 내부로 캡슐화 되기 때문에 두 객체간의 결합도가 낮아진다.
자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다. 
객체지향의 강력함을 누리기 위해 출발점은 책임을 자율적으로 만드는 것이다.

훌륭한 설계자는 미래에 구체적으로 어떤 변경이 발생할지를 예측하지 않는다.
단지 언젠가는 변경이 발생할 것이며 아직까지는 그것이 무엇인지 모른다는 사실을 겸허하게 받아들인다.
좋은 설계는 나중에라도 변경할 수 있는 여지를 남겨놓는 설계다. 

유스케이스
기능적 요구사항이란 시스템이 사용자에게 제공해야하는 기능의 목록을 정리한 것 
사용자와 시스템 간의 상호작용을 보여주는 텍스트이다.
다이어그램에 노력을 쏟지말고, 유스케이스에 담겨있는 내용에 힘써라

시나리오가 아니라 여러 시나리오들의 집합이다.
시나리오를 유스케이스 인스턴스 라고한다.

단순한 피처 목록과 다르다. 

세부정보를 포함하지 마라 

내부 설계와 관련된 정보를 포함하지 않는다.
단지 사용자가 바라보는 시스템의 외부 관점만을 표현한다는 점에 주목하라 
실행 메커니즘에 관한 어떤 정보도 제공하지 않는다.
"단지 사용자가 시스템을 통해 무엇을 얻을 수 있고, 어떻게 상호 작용할 수 있느냐에 관한 정보만 기술된다."
유스케이스는 객체가 아니므로 객체의 구조나 책임에 대한 어떤 정보도 제공하지 않는다.


동적 분류: 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 
정적 분류: 자신의 타입을 변경할 수 없는경우 


슈퍼타입 : 다른 타입보다 일반적
서브타입 : 다른 타입보다 좀 더 특수한 타입 
객체지향에서 내연의 관점에서 슈퍼타입의 정의가 서브타입의 정의보다 더 일반적이라는 것 

